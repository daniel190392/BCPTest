//
//  TransactionInteractor.swift
//  test
//
//  Created by Daniel Salhuana on 4/6/20.
//  Copyright (c) 2020 Daniel Salhuana. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol TransactionBusinessLogic {
    func doLoadCurrencies(request: Transaction.CurrencyLoad.Request)
    func docChangeAmount(request: Transaction.AmountChange.Request)
    func doChangeCurrency(request: Transaction.CurrencyChange.Request)
    func doLoadCurrencySelected(request: Transaction.CurrencySelected.Request)
    func doLoadExchangeCurrencies(request: Transaction.ExchanceCurrencies.Request)
}

protocol TransactionDataStore {
    var currencies: [Currency] { get set }
    var currencyToUpdate: Transaction.CurrencyChange.CurrencyOption? { get set }
    var currencySelected: Currency? { get set }
}

class TransactionInteractor: TransactionBusinessLogic, TransactionDataStore {
    
    var presenter: TransactionPresentationLogic?
    var worker: TransactionWorkerInterface = TransactionWorker()
    var currencies = [Currency]()
    var currencyToUpdate: Transaction.CurrencyChange.CurrencyOption?
    var currencySelected: Currency?
    
    
    private let isoSoles = "PEN"
    private let isoDollar = "USD"
    private var source: Currency? = nil
    private var target: Currency? = nil
    
    func doLoadCurrencies(request: Transaction.CurrencyLoad.Request) {
        worker.doGetConversionRate(completionHandler: {[weak self] (data) in
            guard let data = data, let welf = self else {
                let response = Transaction.Error.Response(errorType: .notLoad)
                presenter?.presentErrorMessage(response: response)
                return
            }
            welf.currencies = welf.worker.doParseConversionRates(data: data)
            validateCurrencies()
        })
    }
    
    func docChangeAmount(request: Transaction.AmountChange.Request) {
        guard let target = target, let source = source, let currencyValue = request.amountValue else {
            let response = Transaction.Error.Response(errorType: .emptyCurrency)
            presenter?.presentErrorMessage(response: response)
            return
        }
        
        let newAmount = worker.convertCurrency(target: target, source: source, amount: currencyValue)
        let response = Transaction.AmountChange.Response(amountChanged: newAmount)
        presenter?.presentAccountChanged(response: response)
    }
    
    func doChangeCurrency(request: Transaction.CurrencyChange.Request) {
        self.currencyToUpdate = request.option
    }
    
    func doLoadCurrencySelected(request: Transaction.CurrencySelected.Request) {
        guard let currencySelected = currencySelected, let currencyToUpdate = currencyToUpdate else {
            return
        }
        
        if currencyToUpdate == .source {
            target = currencySelected.iso == target?.iso ? source : target
            source = currencySelected
        } else if  currencyToUpdate == .target {
            source = currencySelected.iso == source?.iso ? target : source
            target = currencySelected
        }
        
        self.currencySelected = nil
        
        guard let source = source , let target = target else {
            let response = Transaction.Error.Response(errorType: .emptyCurrency)
            presenter?.presentErrorMessage(response: response)
            return
        }
        
        let response = updateCurrencyBuyAndSale(target: target, source: source)
        presenter?.presentLoaded(response: response)
    }
    
    func doLoadExchangeCurrencies(request: Transaction.ExchanceCurrencies.Request) {
        guard let target = target, let source = source else {
            let response = Transaction.Error.Response(errorType: .emptyCurrency)
            presenter?.presentErrorMessage(response: response)
            return
        }
        
        self.source = target
        self.target = source
        
        let response = updateCurrencyBuyAndSale(target: source, source: target)
        presenter?.presentLoaded(response: response)
    }
    
    private func validateCurrencies() {
        guard let source = getCurrencyByIso(currencies: currencies, iso: isoSoles), let target = getCurrencyByIso(currencies: currencies, iso: isoDollar) else {
            let response = Transaction.Error.Response(errorType: .noLocalCurrency)
            presenter?.presentErrorMessage(response: response)
            return
        }
        
        self.source = source
        self.target = target
        let response = updateCurrencyBuyAndSale(target: target, source: source)
        presenter?.presentLoaded(response: response)
    }
    
    private func getCurrencyByIso(currencies: [Currency], iso: String) -> Currency? {
        return currencies.first { (currency) -> Bool in
            return currency.iso == iso
        }
    }
    
    private func updateCurrencyBuyAndSale(target: Currency, source: Currency) -> Transaction.CurrencyLoad.Response {
        let sellRate = worker.buyCurrencyPrice(from: source, to: target)
        let buyRate = worker.sellCurrencyPrice(from: source, to: target)
        return Transaction.CurrencyLoad.Response(source: source , target: target, buyRate: buyRate, sellRate: sellRate)
    }
}
